У програмуванні модулем називають одиницю програмного забезпечення, що має певну функціональність. 
Наприклад, під час створення гри в пінг-понг один модуль може відповідати за логіку гри, а інший модуль — відображати гру на екрані. Кожен модуль складається з окремого файлу, який може бути змінений окремо.

### Writing modules

Модулі в Python — це просто файли Python з розширенням .py. Назва модуля відповідає назві файлу. 
Python модуль може містити набір функцій, класів чи змінних, визначених і реалізованих у ньому. 
Наведений вище приклад містить два файли:

mygame/

- mygame/game.py

- mygame/draw.py

Python-скрипт `game.py` реалізує гру. Він використовує функцію `draw_game` з файлу `draw.py`,
або іншими словами, з модуля `draw`, що реалізує логіку відображення гри на екрані.

Модулі імпортуються з інших модулів за допомогою команди `import`. У цьому прикладі скрипт `game.py` може
виглядати таким чином:

    # game.py
    # import the draw module
    import draw
    
    def play_game():
        ...
    
    def main():
        result = play_game()
        draw.draw_game(result)
        
    # це означає, що якщо цей скрипт виконується, то 
    # main() буде виконана
    if __name__ == '__main__':
        main()

Модуль `draw` може виглядати наступним чином:

    # draw.py
    
    def draw_game():
        ...

    def clear_screen(screen):
        ...

У цьому прикладі модуль `game` імпортує модуль `draw`, що дозволяє йому використовувати функції, реалізовані
в цьому модулі. Функція `main` використовує локальну функцію `play_game` для запуску гри і потім
відображає результат за допомогою функції `draw_game`, реалізованої в модулі `draw`. Щоб використовувати
функцію `draw_game` з модуля `draw`, нам потрібно вказати, в якому модулі функція реалізована, використовуючи оператор крапки. Для звернення до функції `draw_game` з модуля `game`, ми повинні імпортувати модуль `draw` і потім викликати `draw.draw_game()`.

Коли виконується директива `import draw`, інтерпретатор Python шукає файл у директорії, в якій скрипт був виконаний, із назвою модуля та суфіксом `.py`. У цьому випадку шукатиме `draw.py`. Якщо він знайдений, він буде імпортований. Якщо не знайдений, він продовжить шукати вбудовані модулі.

Ви могли помітити, що при імпорті модуля створюється файл `.pyc`. Це — скомпільований файл Python. 
Python компілює файли у байт-код Python, щоб не потрібно було аналізувати файли при щоразове завантаження модулів. Якщо файл `.pyc` існує, він завантажується замість `.py` файлу. Цей процес є прозорим для користувача.

### Importing module objects to the current namespace

Простір імен — це система, у якій кожен об’єкт має ім'я та може бути доступний у Python. Ми імпортуємо функцію `draw_game` у простір імен основного скрипта, використовуючи команду `from`.

    # game.py
    # import the draw module
    from draw import draw_game
    
    def main():
        result = play_game()
        draw_game(result)

Ви могли помітити, що в цьому прикладі назва модуля не передує `draw_game`, тому що ми вказали ім'я модуля,
використовуючи команду `import`.

Переваги такого запису полягають у тому, що вам не потрібно щораз посилатися на модуль. Однак, 
простір імен не може мати два об’єкти з однаковими іменами, тому команда `import` може замінити існуючий об’єкт в просторі імен.

### Importing all objects from a module

Ви можете використовувати команду `import *` для імпорту всіх об'єктів у модулі, наприклад так:

    # game.py
    # import the draw module
    from draw import *
    
    def main():
        result = play_game()
        draw_game(result)

Це може бути трохи ризиковано, оскільки зміни в модулі можуть вплинути на модуль, який його імпортує, але це 
коротше, і не вимагає від вас вказувати кожен об'єкт, який ви хочете імпортувати з модуля.

### Custom import name

Модулі можуть бути завантажені під будь-яким ім'ям, яке ви бажаєте. Це корисно, коли ви імпортуєте модуль умовно
щоб використовувати однакове ім'я в решті коду.

Наприклад, якщо у вас є два модулі `draw` з трохи різними іменами, ви можете зробити наступне:

    # game.py
    # import the draw module
    if visual_mode:
        # у візуальному режимі ми відображаємо за допомогою графіки
        import draw_visual as draw
    else:
        # у текстовому режимі ми виводимо текст
        import draw_textual as draw
    
    def main():
        result = play_game()
        # це може бути візуально або текстово залежно від visual_mode
        draw.draw_game(result)

### Module initialization

Уперше модуль завантажується в запущений скрипт Python, він ініціалізується шляхом виконання коду в модулі один раз. Якщо інший модуль у вашому коді знову імпортує той самий модуль, він не буде завантажений ще раз, тому локальні змінні всередині модуля поводяться як "синглтон", тобто вони ініціалізуються тільки один раз.

Ви можете використовувати це для ініціалізації об'єктів. 
Наприклад:

    # draw.py
    
    def draw_game():
        # під час очищення екрана ми можемо використовувати основний об'єкт екрану, ініціалізований у цьому модулі
        clear_screen(main_screen)
        ...

    def clear_screen(screen):
        ...
        
    class Screen():
        ...

    # ініціалізувати main_screen як синглтон
    main_screen = Screen()

### Extending module load path

Існує кілька способів вказати інтерпретатору Python, де шукати модулі, на додаток до використання
за замовчуванням локального каталогу та вбудованих модулів. Ви можете використовувати змінну оточення `PYTHONPATH` для вказання додаткових каталогів для пошуку модулів, наприклад так:

    PYTHONPATH=/foo python game.py

Це виконує `game.py`, і дозволяє скрипту завантажувати модулі з каталогу `foo`, а також з локального каталогу.

Ви можете також використовувати функцію `sys.path.append`. Виконуйте її *перед* запуском команди `import`:

    sys.path.append("/foo")

Тепер каталог `foo` доданий до списку шляхів, де шукаються модулі.

### Exploring built-in modules

Ознайомтеся з повним списком вбудованих модулів у стандартній бібліотеці Python [тут](https://docs.python.org/3/library/).

Дві дуже важливі функції стануть у нагоді при вивченні модулів у Python - функції `dir` та `help`.

Щоб імпортувати модуль `urllib`, який дозволяє нам читати дані з URL-адрес, ми `import` модуль:

    # import the library
    import urllib

    # use it
    urllib.urlopen(...)
    
Ми можемо подивитися, які функції реалізовані в кожному модулі, за допомогою функції `dir`:

    >>> import urllib
    >>> dir(urllib)
    ['ContentTooShortError', 'FancyURLopener', 'MAXFTPCACHE', 'URLopener', '__all__', '__builtins__', 
    '__doc__', '__file__', '__name__', '__package__', '__version__', '_ftperrors', '_get_proxies', 
    '_get_proxy_settings', '_have_ssl', '_hexdig', '_hextochr', '_hostprog', '_is_unicode', '_localhost', 
    '_noheaders', '_nportprog', '_passwdprog', '_portprog', '_queryprog', '_safe_map', '_safe_quoters', 
    '_tagprog', '_thishost', '_typeprog', '_urlopener', '_userprog', '_valueprog', 'addbase', 'addclosehook', 
    'addinfo', 'addinfourl', 'always_safe', 'basejoin', 'c', 'ftpcache', 'ftperrors', 'ftpwrapper', 'getproxies', 
    'getproxies_environment', 'getproxies_macosx_sysconf', 'i', 'localhost', 'main', 'noheaders', 'os', 
    'pathname2url', 'proxy_bypass', 'proxy_bypass_environment', 'proxy_bypass_macosx_sysconf', 'quote', 
    'quote_plus', 'reporthook', 'socket', 'splitattr', 'splithost', 'splitnport', 'splitpasswd', 'splitport', 
    'splitquery', 'splittag', 'splittype', 'splituser', 'splitvalue', 'ssl', 'string', 'sys', 'test', 'test1', 
    'thishost', 'time', 'toBytes', 'unquote', 'unquote_plus', 'unwrap', 'url2pathname', 'urlcleanup', 'urlencode', 
    'urlopen', 'urlretrieve']

Коли ми знаходимо функцію в модулі, яку хочемо використовувати, ми можемо дізнатися більше про неї за допомогою функції `help`, використовуючи інтерпретатор Python:

    help(urllib.urlopen)

### Writing packages

Пакети - це простори імен, що містять кілька пакетів і модулів. Вони просто директорії, але з певними вимогами.

Кожен пакет у Python - це директорія, яка **ПОВИННА** містити спеціальний файл під назвою `__init__.py`. Цей файл, який може бути порожнім, вказує, що директорія є пакетом Python. Завдяки цьому його можна імпортувати так само, як модуль.

Якщо ми створимо директорію під назвою `foo`, що визначає назву пакету, ми можемо створити модуль всередині цього
пакету під назвою `bar`. Потім ми додаємо файл `__init__.py` всередину директорії `foo`.

Щоб використовувати модуль `bar`, ми можемо імпортувати його двома способами:

    import foo.bar

або:

    from foo import bar

У першому прикладі вище, ми повинні використовувати префікс `foo` кожного разу, коли звертаємося до модуля `bar`. У другому прикладі це не потрібно, тому що ми імпортували модуль у простір імен нашого модуля.

Файл `__init__.py` також може визначити, які модулі пакет експортує як API, зберігаючи інші модулі внутрішніми, перевизначаючи змінну `__all__`, наприклад так:

    __init__.py:

    __all__ = ["bar"]

Exercise
--------

У цій вправі, надрукуйте список всіх функцій в модулі `re`, що містять слово `find`, відсортований в алфавітному порядку.