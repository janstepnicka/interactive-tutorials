تُمثِّل الدوال ```map```, ```filter```, و```reduce``` نماذج من البرمجة الوظيفية. تُتيح هذه الدوال للمبرمج (أنت) كتابة كود أبسط وأقصر، دون الحاجة الُملحة للقلق بشأن التفاصيل الدقيقة مثل الحلقات والشعب البرمجية.

ببساطة، تسمح لك هذه الدوال الثلاث بتطبيق دالة على عدد من العناصر القابلة للتكرار دفعة واحدة. كلٌ من ```map``` و```filter``` مدمجتين في بايثون (في وحدة ```__builtins__```) ولا يحتاجان للاستيراد. بينما تحتاج دالة ```reduce``` للاستيراد لأنها تقع في وحدة ```functools```. دعونا نتعمق في فهم كيفية عمل كل منها، بدءًا بدالة ```map```.

#### Map
تأخذ دالة ```map()``` في بايثون الصيغة التالية:

```map(func, *iterables)```

حيث أن ```func``` هي الدالة التي سيتم تطبيقها على كل عنصر في ```iterables``` (بأي عدد كان). لاحظ وجود النجمة (```*```) على ```iterables```؟ تعني أنه يمكن أن يكون هناك العديد من العناصر القابلة للتكرار طالما أن ```func``` تستقبل هذا العدد تحديدًا كمدخلات. قبل الانتقال إلى مثال، من المهم أن تلاحظ ما يلي:

1. في بايثون 2، تُرجع دالة ```map()``` قائمة. أما في بايثون 3، فتُرجع دالة ```map()``` كائنًا من نوع ```map object```، وهو كائن مولد. للحصول على النتيجة كقائمة، يمكن استدعاء الدالة المدمجة ```list()``` على كائن الخريطة، مثل: ```list(map(func, *iterables))```
2. يجب أن يكون عدد الوسائط للدالة ```func``` هو عدد العناصر القابلة للتكرار المدرجة.

لنرى كيف تنطبق هذه القواعد من خلال الأمثلة التالية.

افترض أن لدي قائمة (```iterable```) تحتوي على أسماء حيواناتي الأليفة المفضلة لدي، جميعها بأحرف صغيرة وأحتاج إليها بأحرف كبيرة. تقليديًا، في البرمجة العادية في بايثون، سأقوم بشيء كهذا:

```python
my_pets = ['alfred', 'tabitha', 'william', 'arla']
uppered_pets = []

for pet in my_pets:
    pet_ = pet.upper()
    uppered_pets.append(pet_)

print(uppered_pets)
```

ستكون النتيجة ```['ALFRED', 'TABITHA', 'WILLIAM', 'ARLA']```

باستخدام دالة ```map()```, ليس الأمر أسهل فقط بل هو أكثر مرونة أيضًا. يمكنني بكل بساطة تنفيذ التالي:

```python
# Python 3
my_pets = ['alfred', 'tabitha', 'william', 'arla']

uppered_pets = list(map(str.upper, my_pets))

print(uppered_pets)
```

وسيطلع النتيجة نفسها. لاحظ أن استخدام الصيغة المعرفة لدالة ```map()``` أعلاه، حيث أن ```func``` في هذه الحالة هي ```str.upper``` و```iterables``` هي قائمة ```my_pets``` -- مجرد عنصر قابل للتكرار واحد. أيضًا نلاحظ أننا لم نستدعِ دالة ```str.upper``` بشكل مباشر (بهذه الطريقة: ```str.upper()```)، حيث تقوم دالة ```map``` بذلك نيابةً عنَّا على _كل عنصر في قائمة ```my_pets```_.

ما هو الأهم أن نلاحظ أن دالة ```str.upper``` تتطلب فقط **وسيطاً واحداً** بحسب تعريفها ولذا قمنا بتمرير مجرد **عنصر قابل للتكرار واحد** إليها. لذا، _إذا كانت الدالة التي تمررها تتطلب اثنين، أو ثلاثة، أو n من الوسائط_، فإن _عليك أن تمرر إليها اثنين، أو ثلاثة، أو n من العناصر القابلة للتكرار_. دعني أوضح ذلك بمثالٍ آخر.

افترض أنني لدي قائمة بمناطق دوائر حسبتها في مكان ما، جميعها بخمسة منازل عشرية. وأحتاج إلى تقريب كل عنصر في القائمة حتى المكان العشري لموقعه، مما يعني أنني يجب أن أقرب العنصر الأول في القائمة إلى مكان عشري واحد، والعنصر الثاني في القائمة إلى مكانين عشريين، والعنصر الثالث إلى ثلاثة، وهكذا. باستخدام ```map()``` هذا الأمر بسيط للغاية. لندعنا نرى كيف.

نعلم أن بايثون توفر لنا دالة ```round()``` المدمجة التي تأخذ وسيطين -- الرقم المراد تقريبه وعدد الأماكن العشرية لتقريب الرقم إليها. لذا، بما أن الدالة تتطلب **وسيطين**، علينا أن نمرر **عنصرين قابلين للتكرار**.

```python
# Python 3

circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

result = list(map(round, circle_areas, range(1, 7)))

print(result)
```

أترى جمال دالة ```map()```؟ هل يمكنك تخيل المرونة التي تثيرها هذه الدالة؟

تعمل دالة ```range(1, 7)``` كوسيط ثانٍ لدالة ```round``` (عدد الأماكن العشرية المطلوبة لكل تكرار). لذا بينما تمر دالة ```map``` عبر عناصر ```circle_areas```, أثناء التكرار الأول، يتم تمرير العنصر الأول من ```circle_areas```, ```3.56773``` مع العنصر الأول من ```range(1,7)```, ```1``` إلى دالة ```round```, مما يجعله يصبح عملياً ```round(3.56773, 1)```. أثناء التكرار الثاني، يتم تمرير العنصر الثاني من ```circle_areas```, ```5.57668``` مع العنصر الثاني من ```range(1,7)```, ```2``` إلى دالة ```round```, مما يجعله يترجم إلى ```round(5.57668, 2)```. يستمر هذا حتى يتم الوصول إلى نهاية القائمة ```circle_areas```.

أنا متأكد أنك تتساءل: "ماذا لو مررت عنصرًا قابلاً للتكرار أقل أو أكثر من طول العنصر الأول؟ أي، ماذا لو مررت ```range(1, 3)``` أو ```range(1, 9999)``` كالعنصر الثاني في الدالة أعلاه". والإجابة بسيطة: لا شيء! حسنًا، هذا ليس صحيحاً بالكامل. لا يحدث "لا شيء" بالمعنى أن دالة ```map()``` لن تثير أي استثناء، بل ستستمر في التكرار على العناصر حتى لا تتمكن من العثور على وسيط ثانٍ للدالة، وعندها تتوقف ببساطة وتعيد النتيجة.

لذا، على سبيل المثال، إذا قمت بتقييم ```result = list(map(round, circle_areas, range(1, 3)))```, لن تحصل على أي خطأ حتى على الرغم من اختلاف طول ```circle_areas``` وطول ```range(1, 3)```. بدلاً من ذلك، هذا ما يفعله بايثون: يأخذ العنصر الأول من ```circle_areas``` والعنصر الأول من ```range(1,3)``` ويمرره للدالة ```round```. تقوم الدالة ```round``` بتقييمها ثم تحفظ النتيجة. ثم تنتقل إلى التكرار الثاني، العنصر الثاني من ```circle_areas``` والعنصر الثاني من ```range(1,3)```, تقوم الدالة ```round``` بحفظه مرة أخرى. الآن، في التكرار الثالث (تحتوي ```circle_areas``` على عنصر ثالث)، يأخذ بايثون العنصر الثالث من ```circle_areas``` ثم يحاول أخذ العنصر الثالث من ```range(1,3)``` ولكن بما أن ```range(1,3)``` ليس لديها عنصر ثالث، يتوقف بايثون ببساطة ويعيد النتيجة، والتي ستكون في هذه الحالة ببساطة ```[3.6, 5.58]```.

جربها بنفسك.

```python
# Python 3

circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

result = list(map(round, circle_areas, range(1, 3)))

print(result)
```

نفس الشيء يحدث إذا كانت ```circle_areas``` أقصر من طول العنصر الثاني القابل للتكرار. يتوقف بايثون ببساطة عندما لا يستطيع العثور على العنصر التالي في أحد العناصر القابلة للتكرار.

لتعزيز معرفتنا بدالة ```map()```, سنستخدمها لتنفيذ دالة ```zip()``` الخاصة بنا. دالة ```zip()``` هي دالة تأخذ عددًا من العناصر القابلة للتكرار ثم تنشئ زوجًا يحتوي على كل من العناصر القابلة للتكرار. مثل دالة ```map()```، في بايثون 3، تعيد كائن مولّد، والذي يمكن تحويله بسهولة إلى قائمة عن طريق استدعاء الدالة المدمجة ```list``` عليها. استخدم جلسة المفسر التالية لفهم دالة ```zip()``` قبل إنشاء دالتنا باستخدام ```map()```

```python
# Python 3

my_strings = ['a', 'b', 'c', 'd', 'e']
my_numbers = [1, 2, 3, 4, 5]

results = list(zip(my_strings, my_numbers))
    
print(results)
```

كمكافأة، هل يمكنك التكهن بما سيحدث في الجلسة السابقة إذا لم يكن ```my_strings``` و```my_numbers``` بنفس الطول؟ لا؟ جربها! غير طول أحدهما.

إلى دالة «zip» المخصصة الخاصة بنا!

```python
# Python 3

my_strings = ['a', 'b', 'c', 'd', 'e']
my_numbers = [1, 2, 3, 4, 5]

results = list(map(lambda x, y: (x, y), my_strings, my_numbers))

print(results)
```

فقط انظر إلى تلك النتيجة! حصلنا على نفس النتيجة مثل ```zip```.

هل لاحظت أيضًا أنني لم أكن بحاجة حتى إلى إنشاء دالة باستخدام الطريقة التقليدية ```def my_function()```؟ هذه هي مدى مرونة دالة ```map()```، وبايثون بشكل عام! لقد استخدمت ببساطة دالة ```lambda```. هذا لا يعني أن استخدام طريقة تعريف الدوال التقليدية ```def function_name()``` غير مسموح، لا، لا يزال مسموحًا. لقد فضلت ببساطة كتابة كود أقل (أن تكون "بايثونيًا").

هذا كل شيء عن دالة map. دعونا ننتقل إلى دالة ```filter()```

#### Filter
بينما تمرر دالة ```map()``` كل عنصر في العنصر القابل للتكرار عبر دالة وتعيد نتيجة جميع العناصر التي مرت عبر الدالة، تتطلب دالة ```filter()``` أولاً أن تُرجع الدالة قيمًا منطقية (صحيحة أو خاطئة) ثم تمرر كل عنصر في العنصر القابل للتكرار عبر الدالة، "لتصفية" تلك التي تصبح خاطئة. لديها الصيغة التالية:

```filter(func, iterable)```

يجب ملاحظة النقاط التالية بشأن دالة ```filter()```:

1. على عكس دالة ```map()```, يتطلب عنصر واحد فقط قابل للتكرار.
2. يجب أن تُرجع الوسيط ```func``` نوعًا منطقياً. إذا لم تفعل، فإن دالة ```filter``` تعيد ببساطة العنصر القابل للتكرار الذي تم تمريره إليها. أيضًا، نظرًا لأن عنصرًا واحدًا فقط قابل للتكرار مطلوب، فمن الضمني أن دالة ```func``` يجب أن تأخذ وسيطًا واحدًا فقط.
3. تمرر دالة ```filter``` كل عنصر في العنصر القابل للتكرار خلال الدالة ```func``` وتعيد **فقط** تلك التي تقيم على أنها صحيحة. أعني، الاسم بحد ذاته - "فلتر".

لنرى بعض الأمثلة

التالي هو قائمة (```iterable```) من الدرجات لعشرة طلاب في امتحان الكيمياء. لِنُرشِّح الطلاب الذين نجحوا بدرجات أكثر من 75... باستخدام دالة ```filter```.

```python
# Python 3
scores = [66, 90, 68, 59, 76, 60, 88, 74, 81, 65]

def is_A_student(score):
    return score > 75

over_75 = list(filter(is_A_student, scores))

print(over_75)
```

المثال التالي سيكون كاشفًا عن الكلمات المقلوبة. "الكلمة المقلوبة" هي كلمة، أو عبارة، أو سلسلة تقرأ من الخلف إيذاءً كما تقرأ من الأمام. دعونا نرشِّح الكلمات التي هي كلمات مقلوبة من مجموعة (```iterable```) من المشتبه بهم بأنها مقلوبة.

```python
# Python 3
dromes = ("demigod", "rewire", "madam", "freer", "anutforajaroftuna", "kiosk")

palindromes = list(filter(lambda word: word == word[::-1], dromes))

print(palindromes)
```

والذي ينبغي أن يُرجع النتيجة ```['madam', 'anutforajaroftuna']```.

رائع، أليس كذلك؟ وأخيرًا، دالة ```reduce()```

#### Reduce
تُطبِّق دالة ```reduce``` دالة **بحتوي على وسيطين** بشكل تراكمي على عناصر عنصر قابل للتكرار، مع إمكانية البدء بوسيط ابتدائي. لديها الصيغة التالية:

```reduce(func, iterable[, initial])```

حيث تكون ```func``` هي الدالة التي يتم تطبيقها بشكل تراكمي على كل عنصر في `````iterable````، و````initial```` هو القيمة الاختيارية التي تُوضع قبل عناصر العنصر القابل للتكرار في الحساب وتعمل كقيمة افتراضية عندما يكون العنصر القابل للتكرار فارغًا. يجب ملاحظة النقاط التالية حول دالة `````reduce()`````:
1. تتطلب الدالة `````func````` وسيطان، الأول هو العنصر الأول في `````iterable````` (إذا لم يتم توفير `````initial`````) والعنصر الثاني في `````iterable`````. إذا تم توفير `````initial`````, فإنه يصبح الوسيط الأول للدالة `````func````` ويصبح العنصر الأول في `````iterable````` العنصر الثاني.
2. تقوم الدالة `````reduce````` "بتقليص" (أعلم، اعذرني) `````iterable````` ليصبح قيمة فردية.

كالعادة، ل

نرى بعض الأمثلة.

لنقم بإنشاء نسختنا الخاصة من دالة `````sum()````` المدمجة في بايثون. تُرجع دالة `````sum()````` مجموع جميع العناصر في العنصر القابل للتكرار الممرر إليها.

 ```python
# Python 3
from functools import reduce

numbers = [3, 4, 6, 9, 34, 12]

def custom_sum(first, second):
    return first + second

result = reduce(custom_sum, numbers)
print(result)
```

والنتيجة كالمتوقع ستكون `````68`````.

إذاً، ماذا حدث؟

كالمعتاد، يتعلق الأمر كله بالتكرار: تأخذ دالة `````reduce````` العنصرين الأول والثاني في `````numbers````` وتمررهما إلى `````custom_sum````` على التوالي. تقوم دالة `````custom_sum````` بحساب مجموعهما وتُعيده إلى `````reduce`````. ثم تأخذ دالة `````reduce````` تلك النتيجة وتطبقها كعنصر أول لدالة `````custom_sum````` وتأخذ العنصر التالي (الثالث) في `````numbers````` كعنصر ثانٍ لدالة `````custom_sum`````. تستمر في هذا (بشكل تراكمي) حتى ينفد `````numbers`````.

لنرى ما يحدث عندما أستخدم القيمة `````initial````` الاختيارية.

```python
# Python 3
from functools import reduce

numbers = [3, 4, 6, 9, 34, 12]

def custom_sum(first, second):
    return first + second

result = reduce(custom_sum, numbers, 10)
print(result)
```

النتيجة، كما تتوقع، هي `````78````` لأن دالة `````reduce````` تستخدم في البداية `````10````` كوسيط أول لدالة `````custom_sum`````.

هذا كل شيء عن دوال بايثون: دالتي `````Map````` و`````Reduce````` و`````Filter`````. حاول تنفيذ التمرين أدناه لمساعدتك في اختبار مدى فهمك لكل دالة.

Exercise
--------
في هذا التمرين، ستستخدم كل من دوال `````map`````, `````filter````` و`````reduce````` لإصلاح الكود المكسور.