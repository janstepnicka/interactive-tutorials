В програмирането модулът е част от софтуера, който има специфична функционалност.
Например, при изграждане на игра на пинг-понг, един модул може да е отговорен за логиката на играта, а
друг модул чертае играта на екрана. Всеки модул се състои от различен
файл, който може да бъде редактиран поотделно.

### Writing modules

Модулите в Python са просто Python файлове с разширение .py. Името на модула е същото като името на файла.
Python модул може да има набор от функции, класове или променливи, които са дефинирани и имплементирани.
Примерът по-горе включва два файла:

mygame/

- mygame/game.py

- mygame/draw.py

Python скриптът `game.py` имплементира играта. Той използва функцията `draw_game` от файла `draw.py`,
или с други думи, `draw` модулът, който имплементира логиката за чертане на играта на екрана.

Модулите се импортират от други модули, като се използва командата `import`. В този пример, скриптът `game.py` може
да изглежда нещо такова:

`draw` модулът може да изглежда нещо такова:

В този пример, `game` модулът импортира `draw` модула, което му позволява да използва функции, имплементирани
в този модул. `main` функцията използва локалната функция `play_game`, за да стартира играта, и след това
рисува резултата от играта, използвайки функция, имплементирана в `draw` модула, наречена `draw_game`. За да се използва
функцията `draw_game` от `draw` модула, трябва да посочим в кой модул е
имплементирана функцията, използвайки точковия оператор. За да реферираме `draw_game` функциите от `game` модула,
трябва да импортираме `draw` модула и след това да извикаме `draw.draw_game()`.

Когато `import draw` директивата се изпълни, Python интерпретаторът търси файл в директорията, в която е изпълнен скриптът, с името на модула и `.py` наставка. В този случай той ще търси `draw.py`. Ако е намерено, то ще бъде импортирано. Ако не е намерено, ще се продължи търсенето на вградени модули.

Може би сте забелязали, че при импортирането на модул се създава `.pyc` файл. Това е компилиран Python файл.
Python компилира файловете в Python байткод, за да не се налага да анализира файловете всеки път, когато модулите се зареждат. Ако `.pyc` файлът съществува, той се зарежда вместо `.py` файла. Този процес е прозрачен за потребителя.

### Импортиране на обекти на модула в текущото пространство от имена

Пространството от имена е система, в която всеки обект е наименован и може да бъде достъпен в Python. Ние импортираме функцията `draw_game` в пространството от имена на главния скрипт, използвайки командата `from`.

Може би сте забелязали, че в този пример името на модула не предшества `draw_game`, защото сме посочили името на модула, използвайки командата `import`.

Предимството на тази нотация е, че няма нужда да реферирате модула многократно. Въпреки това, едно пространство от имена не може да има два обекта с едно и също име, така че командата `import` може да замени съществуващ обект в пространството от имена.

### Импортиране на всички обекти от модул

Можете да използвате командата `import *`, за да импортирате всички обекти в модул по следния начин:

Това може да бъде малко рисковано, тъй като промени в модула могат да засегнат модулът, който го импортира, но е по-кратко и не изисква да се посочва всеки обект, който искате да импортирате от модула.

### Потребителско име за импортиране

Модулите могат да бъдат зареждани под каквото име желаете. Това е полезно при условно импортиране на модул
за използване на едно и също име в останалата част от кода.

Например, ако имате два `draw` модула с леко различни имена, можете да направите следното:

### Инициализация на модула

Първият път, когато модул се зарежда в изпълняващ се Python скрипт, той се инициализира чрез изпълнение на кода в модула веднъж. Ако друг модул във вашия код импортира същия модул отново, той няма да бъде зареден отново, така че локалните променливи в модула действат като "сингълтън", тоест се инициализират само веднъж.

След това можете да използвате това, за да инициализирате обекти.
Например:

### Разширяване на пътя за зареждане на модула

Има няколко начина да кажете на Python интерпретаторът къде да търси модули, освен по подразбиране в локалната директория и вградените модули. Можете да използвате променливата на средата `PYTHONPATH`, за да посочите допълнителни директории, в които да търсите модули като този:

Това изпълнява `game.py` и позволява на скрипта да зарежда модули от `foo` директорията, както и от локалната директория.

Можете също да използвате функцията `sys.path.append`. Изпълнете я *преди* да изпълните `import` командата:

Сега `foo` директорията е добавена към списъка с пътища, където се търсят модули.

### Разглеждане на вградени модули

Вижте пълният списък на вградените модули в стандартната библиотека на Python [тук](https://docs.python.org/3/library/).

Две много важни функции са полезни, когато разглеждаме модули в Python - функциите `dir` и `help`.

За да импортирате модула `urllib`, който ни позволява да четем данни от URL адреси, ние `import` модула:

Можем да потърсим кои функции са имплементирани във всеки модул, като използваме функцията `dir`:

Когато намерим функциите в модула, които искаме да използваме, можем да прочетем повече за тях с функцията `help`, използвайки Python интерпретатора:

### Writing packages

Пакетите са пространства от имена, съдържащи множество пакети и модули. Те са просто директории, но със специфични изисквания.

Всеки пакет в Python е директория, която **ТРЯБВА** да съдържа специален файл, наречен `__init__.py`. Този файл, който може да е празен, указва, че директорията, в която се намира, е Python пакет. Така той може да се импортира по същия начин като модул.

Ако създадем директория, наречена `foo`, която отбелязва името на пакета, можем след това да създадем модул в този
пакет, наречен `bar`. След това добавяме файла `__init__.py` в директорията `foo`.

За да използваме модула `bar`, можем да го импортираме по два начина:

или:

В първия пример по-горе, трябва да използваме префикса `foo`, когато достъпваме модула `bar`. Във втория пример не е необходимо, защото сме импортирали модула в пространството от имена на нашия модул.

Файлът `__init__.py` може също така да реши кои модули пакетът експортира като API, като запазва други модули вътрешни, като презаписва променливата `__all__`, както следва:

Упражнение
--------

В това упражнение, отпечатайте азбучно сортиран списък на всички функции в модула `re`, съдържащи думата `find`.