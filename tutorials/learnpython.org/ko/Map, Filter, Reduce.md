Map, Filter, and Reduce는 함수형 프로그래밍의 패러다임입니다. 이러한 함수는 프로그래머가 루프나 분기와 같은 복잡한 사항을 걱정할 필요 없이 간단하고 짧은 코드를 작성할 수 있게 해줍니다.

본질적으로, 이 세 가지 함수는 여러 반복 가능한 요소에 대해 함수를 한 번에 적용할 수 있게 해줍니다. ```map```과 ```filter```는 Python에 기본적으로 내장되어 있으며 (```__builtins__``` 모듈에서), 따로 임포트할 필요가 없습니다. 그러나 ```reduce```는 ```functools``` 모듈에 있기 때문에 임포트가 필요합니다. 이제 각 함수가 어떻게 동작하는지 더 잘 이해해봅시다. 먼저 ```map```부터 시작해보겠습니다.

#### Map
Python의 ```map()``` 함수는 다음과 같은 구문을 가지고 있습니다:

```map(func, *iterables)```

여기서 ```func```는 ```iterables```(반복 가능한 요소들)에 있는 각 요소에 적용될 함수입니다. ```iterables``` 앞의 별표(```*```)를 주목하세요. 이는 가능한 한 많은 반복 가능한 요소를 사용할 수 있다는 것을 의미합니다. 이는 ```func```가 정확히 필요한 입력 인수 수를 가지는 한 가능합니다. 예를 보기 전에 다음 사항을 주목하세요: 

1. Python 2에서 ```map()``` 함수는 리스트를 반환합니다. 하지만 Python 3에서는 이 함수가 ```map 객체```를 반환하며 이는 제너레이터 객체입니다. 결과를 리스트로 얻으려면 내장된 ```list()``` 함수를 map 객체에 호출할 수 있습니다. 즉, ```list(map(func, *iterables))```
2. ```func```에 대한 인수의 수는 나열된 ```iterables```의 수여야 합니다.

다음 예시를 통해 이러한 규칙들이 어떻게 적용되는지 살펴보겠습니다.

내 즐겨찾는 애완동물 이름(모두 소문자)의 리스트(```iterable```)가 있고 이를 대문자로 변환해야 한다고 가정해봅시다. 전통적으로, 보통의 파이썬 방식으로는 이렇게 합니다:

    my_pets = ['alfred', 'tabitha', 'william', 'arla']
    uppered_pets = []

    for pet in my_pets:
        pet_ = pet.upper()
        uppered_pets.append(pet_)

    print(uppered_pets)

이렇게 하면 ```['ALFRED', 'TABITHA', 'WILLIAM', 'ARLA']```가 출력됩니다.

```map()``` 함수를 사용하면 이 작업이 더 쉽고 유연해집니다. 코드는 다음과 같습니다:

    # Python 3
    my_pets = ['alfred', 'tabitha', 'william', 'arla']

    uppered_pets = list(map(str.upper, my_pets))

    print(uppered_pets)

이 역시 동일한 결과를 출력합니다. 위에서 설명한 ```map()``` 구문을 사용하면, 이 경우 ```func```는 ```str.upper```이고, ```iterables```는 ```my_pets``` 리스트입니다. 단일 반복 가능한 요소일 뿐입니다. 또한 ```str.upper``` 함수를 호출하지 않았다는 점에 주목하세요 (이렇게 하는 것은: ```str.upper()```). 이는 map 함수가 ```my_pets``` 리스트의 각 요소에 대해 ```str.upper```을 호출하기 때문입니다.

중요하게도, ```str.upper``` 함수는 정의상 **하나의** 인수만 요구하며, 따라서 우리는 **하나의** 반복 가능한 요소만 전달했습니다. 따라서, _전달하려는 함수가 두 개, 세 개, 또는 n개의 인수를 요구한다면_, 두 개, 세 개, 또는 n개의 반복 가능한 요소를 전달해야 합니다. 다음 예를 통해 이를 명확히 해보겠습니다.

어디선가 계산된 원의 면적 리스트가 5자리 소수점으로 모두 표시되어 있다고 합시다. 그리고 리스트의 각 요소를 해당 자릿수 소수점 자리까지 반올림해야 한다고 합시다. 즉, 첫 번째 요소는 소수 첫 번째 자리로, 두 번째 요소는 소수 두 번째 자리로, 세 번째 요소는 소수 세 번째 자리로 반올림해야 합니다. ```map()```을 사용하면 이 작업은 매우 간단합니다.

Python은 이미 두 개의 인수를 받는 ```round()``` 내장 함수를 제공합니다. 이 함수는 반올림할 숫자와 반올림할 소수점 자리를 받습니다. 그러므로, 함수가 **두 개의** 인수를 요구하므로, **두 개의** 반복 가능한 요소를 전달해야 합니다.

    # Python 3

    circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

    result = list(map(round, circle_areas, range(1, 7)))

    print(result)

```map()```의 아름다움을 보시겠어요? 이런 유연함이 느껴지나요?

```range(1, 7)``` 함수는 ```round``` 함수의 두 번째 인수로 작동합니다 (각 반복 시 필요한 소수점 수). 따라서 ```map```이 ```circle_areas```를 반복할 때, 첫 번째 반복에서 ```circle_areas```의 첫 번째 요소인 ```3.56773```과 함께 ```range(1,7)```의 첫 번째 요소 ```1```이 ```round```에 전달되어 실질적으로 ```round(3.56773, 1)```이 됩니다. 두 번째 반복에서는, ```circle_areas```의 두 번째 요소인 ```5.57668```과 ```range(1,7)```의 두 번째 요소 ```2```가 전달되어 ```round(5.57668, 2)```로 변환됩니다. 이는 ```circle_areas``` 리스트의 끝에 도달할 때까지 계속됩니다.

"만약 첫 번째 반복 가능한 요소보다 작은 또는 더 많은 반복 가능한 요소를 전달하면 어떻게 될까요? 즉, 위 함수의 두 번째 반복 가능한 요소를 ```range(1, 3)``` 또는 ```range(1, 9999)```로 전달하면 어떻게 될까요?"라고 궁금할 수 있습니다. 그 답은 간단합니다: 아무 일도 일어나지 않습니다! 사실 아무 일도 일어나지 않는다는 건 사실이 아닙니다. ```map()``` 함수는 예외를 일으키지 않습니다. 단지 반복 가능한 요소에 대해 두 번째 인수를 찾을 수 없을 때까지 반복 한 다음 결과를 반환합니다.

예를 들어, ```result = list(map(round, circle_areas, range(1, 3)))```를 평가하면, 비록 ```circle_areas```와 ```range(1, 3)```의 길이가 다르더라도 아무 오류도 발생하지 않습니다. 대신 Python은 이렇게 합니다: ```circle_areas```의 첫 번째 요소와 ```range(1,3)```의 첫 번째 요소를 가져와 ```round```에 전달합니다. ```round```가 이를 계산하고 결과를 저장합니다. 그런 다음 두 번째 반복에서는, ```circle_areas```의 두 번째 요소와 ```range(1,3)```의 두 번째 요소를 받아 다시 저장합니다. 이제 세 번째 반복(```circle_areas```에 세 번째 요소가 있음)에서는, Python이 ```circle_areas```의 세 번째 요소를 가져오고, 『range(1,3)』에서 세 번째 요소를 가져오려 하지만, 일치하는 요소가 없으므로, Python은 간단히 종료하고 결과를 반환합니다. 여기에서는 단순히 ```[3.6, 5.58]```이 됩니다.

직접 시도해보세요.

    # Python 3

    circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

    result = list(map(round, circle_areas, range(1, 3)))

    print(result)


```circle_areas```가 두 번째 반복 가능한 요소의 길이보다 짧아져도 동일한 일이 발생합니다. Python은 반복 가능한 요소 중 하나에서 다음 요소를 찾을 수 없을 때 중지합니다.

```map()``` 함수에 대한 우리의 지식을 강화하기 위해, 사용자 정의 ```zip()``` 함수를 구현해보겠습니다. ```zip()``` 함수는 여러 반복 가능한 요소를 받아 각 요소가 포함된 튜플을 생성합니다. ```map()```과 같이, Python 3에서 그것은 제너레이터 객체를 반환하며, 내장 ```list``` 함수를 호출하여 쉽게 리스트로 변환될 수 있습니다. 아래의 인터프리터 세션을 사용해 ```map()```을 통해 우리의 ```zip()```을 만들기 전에 기존의 ```zip()```을 이해해보세요.

    # Python 3

    my_strings = ['a', 'b', 'c', 'd', 'e']
    my_numbers = [1, 2, 3, 4, 5]

    results = list(zip(my_strings, my_numbers))
    
    print(results)

보너스로 ```my_strings```와 ```my_numbers```가 같은 길이가 아니라면 무슨 일이 일어날지 추측할 수 있나요? 아니요? 시도해보세요! 둘 중 하나의 길이를 변경해보세요.

이제 우리의 사용자 정의 ```zip()``` 함수로 가보겠습니다!

    # Python 3

    my_strings = ['a', 'b', 'c', 'd', 'e']
    my_numbers = [1, 2, 3, 4, 5]

    results = list(map(lambda x, y: (x, y), my_strings, my_numbers))

    print(results)

보세요! ```zip```과 같은 결과를 얻었습니다. 

또한 내가 ```def my_function()``` 표준 방법으로 함수를 생성할 필요조차 없었다는 것을 눈치챘나요? 이는 ```map()``` 및 일반적으로 Python이 얼마나 유연한지를 보여줍니다! 나는 단순히 ```lambda``` 함수를 사용했습니다. 이는 표준 함수 정의 방법(즉, ```def function_name()```)을 사용하는 것이 허용되지 않는다는 것을 의미하지 않으며, 여전히 허용됩니다. 나는 단지 더 적은 코드를 쓰는 것을 선호했기 때문에 ("Pythonic"하게) 그렇게 했을 뿐입니다.

이것이 map에 관한 모든 것입니다. 이제 ```filter()```로 넘어가겠습니다.

#### Filter
```map()```가 반복 가능한 요소의 각 요소를 함수에 통과시키고 모든 요소가 함수를 통과한 결과를 반환하는 반면, ```filter()```는 먼저 함수가 부울 값을 반환해야 하며(참 또는 거짓), 그런 다음 반복 가능한 요소의 각 요소를 함수에 통과시켜 거짓인 요소를 "필터링"합니다. 다음과 같은 구문을 가지고 있습니다:

```filter(func, iterable)```

다음은 ```filter()```에 대해 주목해야 할 사항들입니다:

1. ```map()```과는 달리, 하나의 반복 가능한 요소만 필요합니다.
2. ```func``` 인수는 반드시 부울 타입을 반환해야 합니다. 그렇지 않으면, ```filter```는 단순히 전달된 ```iterable```을 반환합니다. 또한, 하나의 반복 가능한 요소만 필요하므로 ```func```는 암시적으로 하나의 인수만 가져야 합니다.
3. ```filter```는 반복 가능한 요소 내의 각 요소를 ```func```에 통과시키고, 참으로 평가되는 요소만 반환합니다. 이름 그대로 - "필터"입니다.

몇 가지 예시를 살펴보겠습니다.

다음은 화학 시험에서 10명의 학생들의 점수 리스트(```iterable```)입니다. 75점 초과인 학생들을 필터링해봅시다. ```filter```를 사용하여.

    # Python 3
    scores = [66, 90, 68, 59, 76, 60, 88, 74, 81, 65]

    def is_A_student(score):
        return score > 75

    over_75 = list(filter(is_A_student, scores))

    print(over_75)

다음 예시는 회문 감지기입니다. "회문"은 거꾸로 읽어도 동일하게 읽히는 단어, 구 또는 순서입니다. 의심스러운 회문들로 구성된 튜플(```iterable```)에서 회문인 단어들을 필터링해봅시다. 

    # Python 3
    dromes = ("demigod", "rewire", "madam", "freer", "anutforajaroftuna", "kiosk")

    palindromes = list(filter(lambda word: word == word[::-1], dromes))

    print(palindromes)

이는 ```['madam', 'anutforajaroftuna']```를 출력할 것입니다.

참 깔끔하죠? 마지막으로, ```reduce()```입니다.

#### Reduce
```reduce```는 반복 가능한 요소의 각 요소에 누적하여 **두 개의 인수를 갖는** 함수를 적용합니다. 옵션으로 초기 값을 가질 수도 있습니다. 다음과 같은 구문을 가지고 있습니다:

```reduce(func, iterable[, initial])```

여기서 ```func```는 ```iterable```의 각 요소에 누적 적용될 함수이며, ```initial```은 계산에서 반복 가능한 요소의 요소들 앞에 놓여지는 선택적 값으로, 반복 가능한 요소가 비어 있을 때의 기본값 역할을 합니다. ```reduce()```에 대해 주목해야 할 사항은 다음과 같습니다:
1. ```func```는 두 개의 인수를 필요로 하며, 첫 번째 인수는 ```iterable```의 첫 번째 요소이고(만약 ```initial```이 제공되지 않았다면), 두 번째 인수는 ```iterable```의 두 번째 요소입니다. 만약 ```initial```이 제공된 경우, 초기값이 ```func```의 첫 번째 인수가 되고, ```iterable```의 첫 번째 요소가 두 번째 요소가 됩니다.
2. ```reduce```는 ```iterable```을 단일 값으로 "축소"합니다. 

평소처럼, 몇 가지 예를 살펴보겠습니다.

Python의 내장 함수 ```sum()```의 자체 버전을 만들어보겠습니다. ```sum()``` 함수는 전달받은 반복 가능한 요소 내의 모든 항목의 합을 반환합니다.

```python
    # Python 3
    from functools import reduce

    numbers = [3, 4, 6, 9, 34, 12]

    def custom_sum(first, second):
        return first + second

    result = reduce(custom_sum, numbers)
    print(result)
```

결과는 예상대로 ```68```입니다.

그렇다면 무슨 일이 일어났을까요?

평소처럼, 이는 모두 반복에 관한 것입니다: ```reduce```는 ```numbers```의 첫 번째와 두 번째 요소를 받아서 ```custom_sum```에 각각 전달합니다. ```custom_sum```은 그들의 합을 계산하고 그 결과를 ```reduce```에 반환합니다. ```reduce```는 그 결과를 첫 번째 요소로 사용하여 ```custom_sum```에 전달하고, ```numbers```의 다음 요소(세 번째)를 두 번째 요소로 사용합니다. 이것은 ```numbers```가 다 소진될 때까지 계속합니다. 

우리가 ```initial``` 값을 사용할 때 무엇이 일어나는지 살펴봅시다.

```python
    # Python 3
    from functools import reduce

    numbers = [3, 4, 6, 9, 34, 12]

    def custom_sum(first, second):
        return first + second

    result = reduce(custom_sum, numbers, 10)
    print(result)
```

결과는 예상대로 ```78```입니다. 왜냐하면 ```reduce```는 처음에 ```10```을 ```custom_sum```의 첫 번째 인수로 사용하기 때문입니다.

이것이 Python의 Map, Reduce, Filter에 대한 모든 것입니다. 각 함수의 이해도를 확인하기 위해 아래 연습 문제를 시험해보십시오.

Exercise
--------
이 연습에서는 각 ```map```, ```filter```, ```reduce```를 사용하여 깨진 코드를 수정할 것입니다.